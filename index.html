<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Melody Maker</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            text-align: center;
        }
        .note-button {
            display: inline-block;
            width: 50px;
            height: 50px;
            margin: 5px;
            line-height: 50px;
            text-align: center;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            color: #000;
        }
        .note-button.selected {
            border: 2px solid #000;
        }
        #gridCanvas {
            display: block;
            margin: 20px auto;
            border: 1px solid #ccc;
            background-color: #f0f0f0;
        }
        .grid-cell {
            display: inline-block;
            width: 25px;
            height: 50px;
            margin: 2px;
            background-color: #d3d3d3;
            border-radius: 5px;
            cursor: pointer;
            text-align: center;
            line-height: 50px;
        }
    </style>
</head>
<body>

    <h1>Melody Maker</h1>

    <div id="noteButtons">
        <div class="note-button" data-note="C" style="background-color: #FF9999;">C</div>
        <div class="note-button" data-note="C#" style="background-color: #FFB2B2;">C#</div>
        <div class="note-button" data-note="D" style="background-color: #FFCC99;">D</div>
        <div class="note-button" data-note="D#" style="background-color: #FFD9B2;">D#</div>
        <div class="note-button" data-note="E" style="background-color: #FFFF99;">E</div>
        <div class="note-button" data-note="F" style="background-color: #CCFF99;">F</div>
        <div class="note-button" data-note="F#" style="background-color: #B2FFB2;">F#</div>
        <div class="note-button" data-note="G" style="background-color: #99FF99;">G</div>
        <div class="note-button" data-note="G#" style="background-color: #99FFCC;">G#</div>
        <div class="note-button" data-note="A" style="background-color: #99FFFF;">A</div>
        <div class="note-button" data-note="A#" style="background-color: #99CCFF;">A#</div>
        <div class="note-button" data-note="B" style="background-color: #9999FF;">B</div>
        <div class="note-button" data-note="Rest" style="background-color: #808080;">쉼표</div>
    </div>

    <div id="gridCanvas">
        <!-- Grid Cells will be dynamically generated by JavaScript -->
    </div>

    <div>
        <button onclick="resetGrid()">초기화</button>
        <button onclick="saveMelody()">저장</button>
        <button onclick="playMelody()">현재 멜로디 재생</button>
        <button onclick="downloadWAV()">다운로드</button>
    </div>

    <h2>만든 파일 리스트</h2>
    <ul id="melodyList"></ul>

    <script>
        const notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B', 'Rest'];
        const noteFrequencies = {
            'C': 261.63, 'C#': 277.18, 'D': 293.66, 'D#': 311.13, 'E': 329.63,
            'F': 349.23, 'F#': 369.99, 'G': 392.00, 'G#': 415.30, 'A': 440.00,
            'A#': 466.16, 'B': 493.88, 'Rest': 0
        };
        const noteColors = {
            'C': '#FF9999', 'C#': '#FFB2B2', 'D': '#FFCC99', 'D#': '#FFD9B2', 'E': '#FFFF99',
            'F': '#CCFF99', 'F#': '#B2FFB2', 'G': '#99FF99', 'G#': '#99FFCC', 'A': '#99FFFF',
            'A#': '#99CCFF', 'B': '#9999FF', 'Rest': '#808080'
        };
        let selectedNote = null;
        let grid = Array(64).fill(null); // 4마디, 각 마디 16개 그리드
        let savedMelodies = []; // 저장된 멜로디 리스트

        // Generate grid cells
        const gridCanvas = document.getElementById('gridCanvas');
        for (let i = 0; i < 64; i++) {
            const cell = document.createElement('div');
            cell.className = 'grid-cell';
            cell.onclick = () => setNoteInGrid(i);
            gridCanvas.appendChild(cell);
        }

        // Note button selection
        const noteButtons = document.querySelectorAll('.note-button');
        noteButtons.forEach(button => {
            button.onclick = () => {
                noteButtons.forEach(btn => btn.classList.remove('selected'));
                button.classList.add('selected');
                selectedNote = button.dataset.note;
                playNoteSound(selectedNote);
            };
        });

        // Set note in the grid
        function setNoteInGrid(index) {
            if (selectedNote) {
                grid[index] = selectedNote;
                updateGridDisplay();
            }
        }

        // Update grid display
        function updateGridDisplay() {
            const cells = document.querySelectorAll('.grid-cell');
            cells.forEach((cell, index) => {
                const note = grid[index];
                if (note) {
                    cell.textContent = note;
                    cell.style.backgroundColor = noteColors[note];
                } else {
                    cell.textContent = '';
                    cell.style.backgroundColor = '#d3d3d3';
                }
            });
        }

        function resetGrid() {
            grid = Array(64).fill(null);
            updateGridDisplay();
        }

        function saveMelody() {
            let melodyName = prompt("멜로디 이름을 입력하세요");
            if (melodyName) {
                let melody = {
                    name: melodyName,
                    data: [...grid]
                };
                savedMelodies.push(melody);
                updateMelodyList();
            }
        }

        function updateMelodyList() {
            let list = document.getElementById("melodyList");
            list.innerHTML = "";
            savedMelodies.forEach((melody, index) => {
                let item = document.createElement("li");
                item.textContent = melody.name;

                let loadButton = document.createElement("button");
                loadButton.textContent = "불러오기";
                loadButton.onclick = () => loadMelody(index);

                let playButton = document.createElement("button");
                playButton.textContent = "재생하기";
                playButton.onclick = () => playSavedMelody(index);

                let downloadButton = document.createElement("button");
                downloadButton.textContent = "다운로드";
                downloadButton.onclick = () => downloadWAV(index);

                item.appendChild(loadButton);
                item.appendChild(playButton);
                item.appendChild(downloadButton);
                list.appendChild(item);
            });
        }

        function loadMelody(index) {
            grid = savedMelodies[index].data;
            updateGridDisplay();
        }

        function playNoteSound(note) {
    let audioContext = new (window.AudioContext || window.webkitAudioContext)();
    if (noteFrequencies[note] > 0) {
        let oscillator = audioContext.createOscillator();
        oscillator.type = 'sine';
        oscillator.frequency.setValueAtTime(noteFrequencies[note], audioContext.currentTime);
        
        oscillator.connect(audioContext.destination);
        oscillator.start();
        oscillator.stop(audioContext.currentTime + 0.25); // 음을 0.25초 동안 재생
    }
}

function playMelody() {
    let audioContext = new (window.AudioContext || window.webkitAudioContext)();
    let currentTime = audioContext.currentTime;

    grid.forEach((note, index) => {
        if (note && noteFrequencies[note] > 0) {
            let oscillator = audioContext.createOscillator();
            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(noteFrequencies[note], currentTime + index * 0.25);

            oscillator.connect(audioContext.destination);
            oscillator.start(currentTime + index * 0.25);
            oscillator.stop(currentTime + index * 0.25 + 0.25); // 음을 0.25초 동안 재생
        }
    });
}

function playSavedMelody(index) {
    let melody = savedMelodies[index].data;
    let audioContext = new (window.AudioContext || window.webkitAudioContext)();
    let currentTime = audioContext.currentTime;

    melody.forEach((note, noteIndex) => {
        if (note && noteFrequencies[note] > 0) {
            let oscillator = audioContext.createOscillator();
            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(noteFrequencies[note], currentTime + noteIndex * 0.25);

            oscillator.connect(audioContext.destination);
            oscillator.start(currentTime + noteIndex * 0.25);
            oscillator.stop(currentTime + noteIndex * 0.25 + 0.25); // 음을 0.25초 동안 재생
        }
    });
}



        function downloadWAV(index = null) {
            let melody = index !== null ? savedMelodies[index].data : grid;
            let audioContext = new (window.AudioContext || window.webkitAudioContext)();
            let sampleRate = audioContext.sampleRate;
            let buffer = audioContext.createBuffer(1, sampleRate * 4, sampleRate); // 4초 길이
            let data = buffer.getChannelData(0);

            generateSoundData(data, melody, sampleRate);

            let wav = audioBufferToWav(buffer);
            let blob = new Blob([new DataView(wav)], { type: 'audio/wav' });
            let url = URL.createObjectURL(blob);
            let a = document.createElement('a');
            a.style.display = 'none';
            a.href = url;
            a.download = index !== null ? savedMelodies[index].name + '.wav' : 'melody.wav';
            document.body.appendChild(a);
            a.click();
            window.URL.revokeObjectURL(url);
        }

        function generateSoundData(data, melody, sampleRate) {
            for (let i = 0; i < data.length; i++) {
                data[i] = 0; // Initialize with silence
            }
            melody.forEach((note, index) => {
                if (note && noteFrequencies[note] > 0) {
                    let frequency = noteFrequencies[note];
                    let startTime = index * (sampleRate / 16);
                    for (let i = 0; i < sampleRate / 16; i++) {
                        data[startTime + i] += Math.sin(2 * Math.PI * frequency * (i / sampleRate));
                    }
                }
            });
        }

        function audioBufferToWav(buffer) {
            let numOfChan = buffer.numberOfChannels,
                length = buffer.length * numOfChan * 2 + 44,
                bufferArray = new ArrayBuffer(length),
                view = new DataView(bufferArray),
                channels = [],
                i,
                sample,
                offset = 0,
                pos = 0;

            // write WAV header
            setUint32(0x46464952); // "RIFF"
            setUint32(length - 8); // file length - 8
            setUint32(0x45564157); // "WAVE"

            setUint32(0x20746d66); // "fmt " chunk
            setUint32(16); // length = 16
            setUint16(1); // PCM (uncompressed)
            setUint16(numOfChan);
            setUint32(buffer.sampleRate);
            setUint32(buffer.sampleRate * 2 * numOfChan); // avg. bytes/sec
            setUint16(numOfChan * 2); // block-align
            setUint16(16); // 16-bit (hardcoded in this demo)

            setUint32(0x61746164); // "data" - chunk
            setUint32(length - pos - 4); // chunk length

            // write interleaved data
            for (i = 0; i < buffer.numberOfChannels; i++)
                channels.push(buffer.getChannelData(i));

            while (pos < length) {
                for (i = 0; i < numOfChan; i++) {
                    sample = Math.max(-1, Math.min(1, channels[i][offset])); // clamp
                    sample = (sample < 0 ? sample * 0x8000 : sample * 0x7FFF) | 0; // scale to 16-bit signed int
                    view.setInt16(pos, sample, true); // write 16-bit sample
                    pos += 2;
                }
                offset++; // next source sample
            }

            return bufferArray;

            function setUint16(data) {
                view.setUint16(pos, data, true);
                pos += 2;
            }

            function setUint32(data) {
                view.setUint32(pos, data, true);
                pos += 4;
            }
        }

    </script>

</body>
</html>
